## Beta - PLS regression coefficients matrix (K x M)
## W - PLS weights matrix for X (K x A)
## P - PLS loadings matrix for X (K x A)
## Q - PLS loadings matrix for Y (M x A)
## R - PLS weights matrix to compute scores T directly from original X (K x A)

## VIP returns all VIP values for all variables and all number of components,
## as a ncomp x nvars matrix.
VIP <- function(Q,T,W) {
    SS <- c(Q)^2 * colSums(T^2)
    Wnorm2 <- colSums(W^2)
    SSW <- sweep(W^2, 2, SS / Wnorm2, "*")
    sqrt(nrow(SSW) * apply(SSW, 1, cumsum) / cumsum(SS))
}

## VIPjh returns the VIP of variable j with h components
VIPjh <- function(Q,T,W, j, h) {
    b <- c(Q)[1:h]
    T <- T[,1:h, drop = FALSE]
    SS <- b^2 * colSums(T^2)
    W <- W[,1:h, drop = FALSE]
    Wnorm2 <- colSums(W^2)
    sqrt(nrow(W) * sum(SS * W[j,]^2 / Wnorm2) / sum(SS))
}

# Running sbt "run ./data/artificial3.csv 3" produces the following output:
# model
# Beta
# -5.000000000000015
# 2.0000000000000075
# 7.000000000000008
# W
# 0.4914654743374427  -0.8305457605463002  0.26202180667422725
# 0.5656959306039092  0.07569161268778543  -0.821132689561771
# 0.6621554210549436  0.5517830365345512   0.5070361712543064
# P
# 0.5426893246047337  -0.8497058606621573  0.26202180667425834
# 0.5610276558152224  0.13573617439851055  -0.8211326895617392
# 0.6281242418157817  0.5147064896360263   0.5070361712543412
# Q
# 2.8054783813172492  8.122947079560001  0.5968787862856082
# R
# 0.4914654743374427  -0.8002346626334702  0.20350539368234274
# 0.5656959306039092  0.11058086867171946  -0.8130465667250923
# 0.6621554210549436  0.592621424680057    0.5503710599485043
# vip
# ArrayBuffer((c,1.1198453217362405), (a,0.9632168952008574), (b,0.9045217897790391))
# [success] Total time: 2 s, completed Dec 7, 2015 10:53:02 PM

# The following variables, W, Q, R, X, and T, are hard-coded with the values produced by the command 'sbt "run ./data/artificial3.csv 3"'
W <- matrix(c(0.4914654743374427, -0.8305457605463002, 0.26202180667422725, 0.5656959306039092, 0.07569161268778543, -0.821132689561771, 0.6621554210549436, 0.5517830365345512, 0.5070361712543064), 3, 3)
W <- t(W)
Q <- matrix(c(2.8054783813172492, 8.122947079560001, 0.5968787862856082), 1, 3)
R <- matrix(c(0.4914654743374427,  -0.8002346626334702,  0.20350539368234274, 0.5656959306039092,  0.11058086867171946,  -0.8130465667250923, 0.6621554210549436,  0.592621424680057,    0.5503710599485043), 3, 3)
R <- t(R)
X <- matrix(c( 90481.0,87111.0,98371.0, 28318.0,55670.0,86011.0, 73487.0,31259.0,60896.0, 57958.0,88628.0,51754.0, 77010.0,74398.0,85953.0 ), 5, 3, byrow = TRUE)
T <- X %*% R


VIP(Q, T, W)
          [,1]      [,2]     [,3]
[1,] 0.8512432 0.9798141 1.146887
[2,] 0.9635219 0.9039795 1.120021
[3,] 0.9632169 0.9045218 1.119845

# which means my VIP calculation produces the same VIP scores as http://mevik.net/work/software/VIP.R, because the third row of
# [,1]      [,2]     [,3]
# [1,] 0.8512432 0.9798141 1.146887
# [2,] 0.9635219 0.9039795 1.120021
# [3,] 0.9632169 0.9045218 1.119845
# is equivalent to ArrayBuffer((c,1.1198453217362405), (a,0.9632168952008574), (b,0.9045217897790391))
#
# Running 'sbt "run ./data/artificial3.csv 2"' produces:
# model
# Beta
# -5.121468052383706
# 2.4852902479405614
# 6.671495189731221
# W
# 0.4914654743374427  -0.8305457605463002
# 0.5656959306039092  0.07569161268778543
# 0.6621554210549436  0.5517830365345512
# P
# 0.5426893246047337  -0.8497058606621573
# 0.5610276558152224  0.13573617439851055
# 0.6281242418157817  0.5147064896360263
# Q
# 2.8054783813172492  8.122947079560001
# R
# 0.4914654743374427  -0.8002346626334702
# 0.5656959306039092  0.11058086867171946
# 0.6621554210549436  0.592621424680057
# vip
# ArrayBuffer((c,1.120020804249607), (a,0.9635218940233102), (b,0.9039795118174951))
#
# and ArrayBuffer((c,1.120020804249607), (a,0.9635218940233102), (b,0.9039795118174951)) is equivalent to the second row of
# [,1]      [,2]     [,3]
# [1,] 0.8512432 0.9798141 1.146887
# [2,] 0.9635219 0.9039795 1.120021
# [3,] 0.9632169 0.9045218 1.119845
#
# Finally, 'sbt "run ./data/artificial3.csv 1"' produces:
# ...
# ArrayBuffer((c,1.146886831774325), (b,0.9798140934409285), (a,0.8512431717183889))
# which is equivalent to the first row of
# [,1]      [,2]     [,3]
# [1,] 0.8512432 0.9798141 1.146887
# [2,] 0.9635219 0.9039795 1.120021
# [3,] 0.9632169 0.9045218 1.119845
